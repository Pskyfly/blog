<!doctype html>
<html>

<head>
	<meta charset='UTF-8'>
	<meta name='viewport' content='width=device-width initial-scale=1'>
	<title>第五周学习报告</title>
	<link rel="stylesheet" href="layui/css/layui.css">
	<script src="layui/layui.js"></script>
</head>

<body>
	<!--导航条-->
	<div class="margin-left:20px">
		<ul class="layui-nav" lay-filter="">
		  <li class="layui-nav-item"><a style="font-size: large;font-style: italic;">Pskyfly's Blog<a></li>
		  <li class="layui-nav-item layui-col-md-offset8"><a href="/homepage">首页</a></li>
		  <li class="layui-nav-item"><a href="/problems">刷题记录</a></li>
		  <li class="layui-nav-item">
			<a href="javascript:;">学习笔记</a>
			<dl class="layui-nav-child">
			  <!-- 二级菜单 -->
			  <dd><a href="/linux">Linux基础</a></dd>
			  <dd><a href="/layui">LayUI框架</a></dd>
			  <dd><a href="/acm">ACM-ICPC训练</a></dd>
			</dl>
		  </li>
		</ul>
	  </div>
	  <!--导航条-->
	<h1 id='第五周学习报告------李天航'>第五周学习报告——李天航</h1>
	<h2 id='线段树和树状数组'>线段树和树状数组</h2>
	<h3 id='线段树'>线段树</h3>
	<p>线段树的代码量很大，常数也很大，但是它的使用会比树状数组更加灵活（也更加难），下面放上线段树的模板。线段树n个节点最多会有4n-1（1+2+4+……+2^(logn+1)+2*n）个树结点，所以在开内存空间时，需要开4倍的空间。而遍历的时候也大概需要4logn个结点，而树状数组只有一个logn，所以线段树的常数比较大，
	</p>
	<pre><code class='language-c++' lang='c++'>//求区间最大数
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

using namespace std;

const int N = 2e5 + 10;

struct Node {
    int l, r;
    int data;
} tr[N * 4];//开四倍的空间，将区间视为结点

void pushup(int u) {//用子节点更新父节点
    tr[u].data = max(tr[u &lt;&lt; 1].data, tr[u &lt;&lt; 1 | 1].data);
}

void build(int u, int l, int r) {//初始化，建树
    tr[u].l = l, tr[u].r = r;
    if (l == r) {
        return;
    }
    int mid = (l + r) &gt;&gt; 1;
    build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
    pushup(u);  //这里也可以不用, 因为相当于初始化了一个全为0的线段树
}

void change(int u, int x, int v) {//单点修改，u为当前区间的编号
    if (tr[u].l == x &amp;&amp; tr[u].r == x) {
        tr[u].data = v;
    } else {
        int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
        if (x &lt;= mid)
            change(u &lt;&lt; 1, x, v);
        else 
            change(u &lt;&lt; 1 | 1, x, v);
        pushup(u);
    }
}

int query(int u, int l, int r) {//查询
    if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) {
        return tr[u].data;
    }
    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
    int v = 0;
    if (l &lt;= mid) {
        v = query(u &lt;&lt; 1, l, r);
    }
    if (r &gt; mid) {
        v = max(v, query(u &lt;&lt; 1 | 1, l, r));
    }
    return v;
}

int m, p;

int main() {
    cin &gt;&gt; m &gt;&gt; p;
    int n = 0, last = 0;
    build(1, 1, m);
    int x;
    char op[2];
    while (m--) {
        scanf(&quot;%s%d&quot;, op, &amp;x);
        if (*op == &#39;Q&#39;) {
            last = query(1, n - x + 1, n);//强制在线
            printf(&quot;%d\n&quot;, last);
        } else {
            change(1, n + 1, (last + x) % p);
            n++;
        }
    }
    return 0;
}
//区间修改
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

typedef long long LL;

const int N = 1e5 + 10;
int n, m;
int w[N];
struct Node
{
    int l, r;
    LL sum, add;
}tr[N * 4];

void pushup(int u)
{
    tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
}
void pushdown(int u)
{
    auto &amp;root = tr[u], &amp;left = tr[u &lt;&lt; 1], &amp;right = tr[u &lt;&lt; 1 | 1];
    if (root.add)
    {
        //传递懒标记，更新子树
        left.add += root.add, left.sum += (LL) (left.r - left.l + 1) * root.add;
        right.add += root.add, right.sum += (LL) (right.r - right.l + 1) * root.add;
        //删除父结点懒标记
        root.add = 0;
    }
}
void build(int u, int l, int r)
{
    if (l == r) tr[u] = {l, r, w[l], 0};
    else
    {
        tr[u] = {l, r};
        int mid = l + r &gt;&gt; 1;
        build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
        pushup(u);
    }
}
void modify(int u, int l, int r, int v)
{
    if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)
    {
        tr[u].sum += (tr[u].r - tr[u].l + 1) * v;
        tr[u].add += v;
    }
    else
    {
        pushdown(u);
        int mid = tr[u].l + tr[u].r &gt;&gt; 1;
        if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, v);
        if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, v);
        pushup(u);
    }
}
LL query(int u, int l, int r)
{
    if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum;

    pushdown(u);
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    LL v = 0;
    if (l &lt;= mid) v = query(u &lt;&lt; 1, l, r);
    if (r &gt; mid) v += query(u &lt;&lt; 1 | 1, l, r);
    return v;
}
int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;w[i]);
    build(1, 1, n);

    char op[2];
    int l, r, t;
    while (m -- )
    {
        scanf(&quot;%s%d%d&quot;, op, &amp;l, &amp;r);
        if (*op == &#39;Q&#39;) printf(&quot;%lld\n&quot;, query(1, l, r));
        else
        {
            scanf(&quot;%d&quot;, &amp;t);
            modify(1, l, r, t);
        }
    }
    return 0;
}

//有乘法和取模
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;unordered_map&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#include&lt;ctime&gt;
#include&lt;limits.h&gt;
#include &lt;stack&gt;
#include&lt;set&gt;
#include&lt;iomanip&gt;
#define ll long long
#define um unordered_map
#pragma warning(disable : 4996)
using namespace std;
#define rep(l,a,b) for(ll l=a;l&lt;=b;l++)
#define repp(l,a,b) for(ll l=a;l&gt;=b;l--)
#define mem(x) memset(x,0,sizeof(x))
#define fr fast_IO::read()
#define INF 0x3f3f3f3f
namespace fast_IO {
	ll read() {
		ll num = 0;
		char c;
		bool tag = false;
		while ((c = getchar()) != &#39;-&#39; &amp;&amp; c != &#39;+&#39; &amp;&amp; (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) &amp;&amp; ~c);
		if (!~c)return EOF;
		if (c == &#39;-&#39;)tag = true;
		else if (c == &#39;+&#39;)tag = false;
		else num = c ^ 48;
		while ((c = getchar()) &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)
			num = (num &lt;&lt; 1) + (num &lt;&lt; 3) + (c ^ 48);
		if (tag)return -num;
		return num;
	}
}
const ll mod = 50001;
#define N 1000000
int ll n, m, p, a[N], ans[N &lt;&lt; 2], tag[N &lt;&lt; 2];
struct node
{
	ll v, mul, add;//线段树结构体，v表示此时的答案，mul表示乘法意义上的lazytag，add是加法意义上的
}st[400007];
void bt(int root, int l, int r)//初始化
{
	st[root].mul = 1;
	st[root].add = 0;
	if (l == r)
		st[root].v = a[l];
	else
	{
		int m = l + r &gt;&gt; 1;
		bt(root &lt;&lt; 1, l, m);
		bt(root &lt;&lt; 1 | 1, m + 1, r);
		st[root].v = st[root &lt;&lt; 1].v + st[root &lt;&lt; 1 | 1].v;
	}
	st[root].v %= p;
}
void pushdown(int root, int l, int r)//维护lazytag
{
	int m = l + r &gt;&gt; 1;
	int ls = root &lt;&lt; 1; int rs = root &lt;&lt; 1 | 1;
	st[ls].v = (st[ls].v * st[root].mul + st[root].add * (m - l + 1)) % p;
	st[rs].v = (st[rs].v * st[root].mul + st[root].add * (r - m)) % p;
	st[ls].mul = (st[root].mul * st[ls].mul) % p;
	st[rs].mul = (st[root].mul * st[rs].mul) % p;
	st[ls].add = (st[ls].add * st[root].mul + st[root].add) % p;
	st[rs].add = (st[rs].add * st[root].mul + st[root].add) % p;
	st[root].mul = 1;
	st[root].add = 0;
}
void ud1(int root, int stdl, int stdr, int l, int r, ll k)
{
	if (r &lt; stdl || stdr &lt; l)
		return;
	if (l &lt;= stdl &amp;&amp; stdr &lt;= r)
	{
		st[root].v = (st[root].v * k) % p;
		st[root].mul = (st[root].mul * k) % p;
		st[root].add = (st[root].add * k) % p;
		return;
	}
	pushdown(root, stdl, stdr);
	int m = (stdl + stdr) &gt;&gt; 1;
	ud1(root &lt;&lt; 1, stdl, m, l, r, k);
	ud1(root &lt;&lt; 1 | 1, m + 1, stdr, l, r, k);
	st[root].v = (st[root &lt;&lt; 1].v + st[root &lt;&lt; 1 | 1].v) % p;
	return;
}
void ud2(int root, int stdl, int stdr, int l, int r, ll k)
{
	if (r &lt; stdl || stdr &lt; l)
		return;
	if (l &lt;= stdl &amp;&amp; stdr &lt;= r)
	{
		st[root].add = (st[root].add + k) % p;
		st[root].v = (st[root].v + k * (stdr - stdl + 1)) % p;
		return;
	}
	pushdown(root, stdl, stdr);
	int m = stdl + stdr &gt;&gt; 1;
	ud2(root &lt;&lt; 1, stdl, m, l, r, k);
	ud2(root &lt;&lt; 1 | 1, m + 1, stdr, l, r, k);
	st[root].v = (st[root &lt;&lt; 1].v + st[root &lt;&lt; 1 | 1].v) % p;
	return;
}
ll query(int root, int stdl, int stdr, int l, int r)
{
	if (r &lt; stdl || stdr &lt; l)
		return 0;
	if (l &lt;= stdl &amp;&amp; stdr &lt;= r)
		return st[root].v;
	pushdown(root, stdl, stdr);
	int m = stdl + stdr &gt;&gt; 1;
	return (query(root &lt;&lt; 1, stdl, m, l, r) + query(root &lt;&lt; 1 | 1, m + 1, stdr, l, r)) % p;
}
signed main()
{
	//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	cin &gt;&gt; n &gt;&gt; m&gt;&gt;p;
	rep(i, 1, n)
		a[i] = fr;
	bt(1, 1, n);
	while (m--)
	{
		int chk = fr;
		int x, y;
		ll k;
		if (chk == 1)
			x = fr, y = fr, k = fr, ud1(1, 1, n, x, y, k);
		else if (chk == 2)
			x = fr, y = fr, k = fr, ud2(1, 1, n, x, y, k);
		else
			x = fr, y = fr, printf(&quot;%lld\n&quot;, query(1, 1, n, x, y));
	}
}
//有平方和
const ll mod = 50001;
#define N 10000000
int n, m;
double w[N];
struct Node
{
	int l, r;
	double sum, sum2, add;
}tr[N * 4];
void pushup(int u)
{
	tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;
	tr[u].sum2 = tr[u &lt;&lt; 1].sum2 + tr[u &lt;&lt; 1 | 1].sum2;
}
void pushdown(int u)
{
	auto&amp; root = tr[u], &amp; left = tr[u &lt;&lt; 1], &amp; right = tr[u &lt;&lt; 1 | 1];
	if (root.add)
	{
		double k = root.add;
		left.add += k;
		left.sum2 += (left.r - left.l + 1) * k * k + 2 * k * left.sum;
		left.sum += (left.r - left.l + 1) * k;
		right.add += k;
		right.sum2 += (right.r - right.l + 1) * k * k + 2 * k * right.sum;
		right.sum += (right.r - right.l + 1) * k;
		root.add = 0;
	}
}
void build(int u, int l, int r)
{
	if (l == r) tr[u] = { l, r, w[l],w[l] * w[l], 0 };
	else
	{
		tr[u] = { l, r,0,0,0 };
		int mid = l + r &gt;&gt; 1;
		build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r);
		pushup(u);
	}
}

void modify(int u, int l, int r, double v)
{
	if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)
	{
		tr[u].sum2 += (tr[u].r - tr[u].l+1) * v * v + 2 * v * tr[u].sum;//误写成n
		tr[u].sum += (tr[u].r - tr[u].l + 1) * v;
		tr[u].add += v;
	}
	else
	{
		pushdown(u);
		int mid = tr[u].l + tr[u].r &gt;&gt; 1;
		if (l &lt;= mid) modify(u &lt;&lt; 1, l, r, v);
		if (r &gt; mid) modify(u &lt;&lt; 1 | 1, l, r, v);
		pushup(u);
	}
}
double query(int u, int l, int r)
{
	if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum;
	pushdown(u);
	int mid = tr[u].l + tr[u].r &gt;&gt; 1;
	double v = 0;//写成ll……
	if (l &lt;= mid) v = query(u &lt;&lt; 1, l, r);
	if (r &gt; mid) v += query(u &lt;&lt; 1 | 1, l, r);
	return v;
}
double query2(int u, int l, int r)
{
	if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum2;
	pushdown(u);
	int mid = tr[u].l + tr[u].r &gt;&gt; 1;
	double v = 0;
	if (l &lt;= mid) v = query2(u &lt;&lt; 1, l, r);//没加2
	if (r &gt; mid) v += query2(u &lt;&lt; 1 | 1, l, r);
	return v;
}
signed main()
{
	freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
	rep(i, 1, n) scanf(&quot;%lf&quot;, &amp;w[i]);
	build(1, 1, n);
	int op, x, y;
	double k;
	while (m--)
	{
		scanf(&quot;%lld%lld%lld&quot;, &amp;op, &amp;x, &amp;y);
		if (op == 1)
		{
			scanf(&quot;%lf&quot;, &amp;k);
			modify(1, x, y, k);
		}
		else if (op == 2)
		{
			printf(&quot;%.4f\n&quot;, query(1, x, y) / (double)(y - x + 1));
			//printf(&quot;%lf\n&quot;, query(1, x, y));
		}
		else
		{
			double num = query(1, x, y) / (y - x + 1);
			printf(&quot;%.4f\n&quot;, query2(1, x, y) / (double)(y - x + 1) - num * num);
			//printf(&quot;%lf\n&quot;, query2(1, x, y));
		}
	}
	return 0;
}
</code></pre>
	<h3 id='树状数组'>树状数组</h3>
	<p>树状数组是用于维护前缀和的数据结构，支持单点的查询和修改，如果要修改区间的值则需要用到差分数组。数字太大时可以在排序后进行离散化。</p>
	<p>树状数组原理详解：</p>
	<p>首先我们需要知道lowbit(x)是返回x的最后一个1，例如二进制数10100就返回100.</p>
	<p>树状数组的核心思想是将一个数分解成若干零件，在维护的时候，直接对这些零件进行处理，在查询的时候再将这些零件组装成我们想要的数。</p>
	<p>我们先来看看树状数组是如何查询的：</p>
	<pre><code class='language-c++' lang='c++'>ll query(int p)
{
	ll ans = 0;
	for (; p; p -= lowbit(p))
		ans += f[p];
	return ans;
}
</code></pre>
	<p>仔细观察可以发现，查询的过程是将数p进行了二进制分解。</p>
	<p>例如：二进制数p为1101，我们就要将它分解为：</p>
	<p>1101</p>
	<p>1100</p>
	<p>1000</p>
	<p>分解的方式是减去上一个数的最后一个1</p>
	<p>那么，为什么这种分解方式是正确的呢，也就是要证明这些零件包含了p之前前的每一个数，并且值包含一次。</p>
	<p>然后我们在观察它的插入过程：</p>
	<pre><code class='language-c++' lang='c++'>void insert(int p, int k)
{
	for (; p &lt;= n; p += lowbit(p))
		f[p] += k;
}
</code></pre>
	<p>可以发现如下规律：</p>
	<p>以4位二进制数为例</p>
	<p>从0001到1000的数都会被累加到1000当中</p>
	<p>从1001到1100的数都会被累加到1100当中</p>
	<p>从1101到1110的数都会被累加到1110当中</p>
	<p>1111单独加到1111当中</p>
	<p>例如0110-&gt;1000，0101-&gt;0110-&gt;1000，1010-&gt;1100</p>
	<p>这些1000,1100,1110,1111就是所有的零件，所有的前缀和都可以由他们组合得到，并且不重不漏，他们的特点是加上lowbit后会变成10000，也就是他们最终会统合到10000中，所有小于等于10000的数都会被统计到10000中，所以我们也递归地证明了所有小于等于1000的数会统计到1000当中。加上lowbit操作本质上是产生进位，填补lowbit位后的第一个0，然后把这个0后面的位都变成0，而从0001到0111中，第一位都是0，所以在不断加上lowbit后，一定会到达1000这个数，把值传给他。1001到1011也是一样，第二位总是0，在不断加上lowbit后，一定会把第二位变成1，也就是1100。而1000，1100，1110,1111均可视为01000,01100,01110,01111，他们的第一位也总是0，所以一定会累加到10000当中，也就通过lowbit形成了一棵树，我们称其为树状数组。
	</p>
	<p>单点修改和区间查询：</p>
	<pre><code class='language-c++' lang='c++'>const ll mod = 50001;
#define N 1000000
ll n;
struct pp
{
	ll num, rank;
}a[N];
ll f[N];
bool cmp(pp a, pp b)
{
	if (a.num == b.num)
		return a.rank &lt; b.rank;
	else
		return a.num &lt; b.num;
}
ll lowbit(ll x)
{
	return x &amp; (-x);
}
void insert(int p, int k)
{
	for (; p &lt;= n; p += lowbit(p))
		f[p] += k;
}
ll query(int p)
{
	ll ans = 0;
	for (; p; p -= lowbit(p))
		ans += f[p];
	return ans;
}
ll ind[N];
signed main()
{
	//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	cin &gt;&gt; n;
	ll ans = 0;
	rep(i, 1, n)
		a[i].num = fr,a[i].rank=i;
	sort(a + 1, a + 1 + n,cmp);
	rep(i, 1, n)
		ind[a[i].rank] = i;//把排名填到原来的位置
	rep(i, 1, n)
	{
		insert(ind[i], 1);
		ans += i - query(ind[i]);
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
	<p>区间修改和区间查询：</p>
	<pre><code class='language-c++' lang='c++'>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;
int n, m;
int a[N];
LL tr[N], tri[N];
//tr[]数组是原始数组的差分数组d[i]的树状数组
//tri[]数组是原始数组的差分数组乘以i即i*d[i]的树状数组

int lowbit(int x)
{
    return x &amp; -x;
}
void add(LL c[], int x, int v)
{
    for (int i = x; i &lt;= n; i += lowbit(i))
        c[i] += v;
}
LL query(LL c[], int x)
{
    LL res = 0;
    for (int i = x; i; i -= lowbit(i))
        res += c[i];
    return res;
}
//对应最后一步推导的公式
LL get_sum(int x)
{
    return query(tr, x) * (x + 1) - query(tri, x);
}
int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    //输入数组a[i]
    for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]);
    //先构造两个数组 d[i] 和 i*d[i]
    for (int i = 1; i &lt;= n; ++i) 
        tr[i] = a[i] - a[i - 1], tri[i] = tr[i] * i;
    //原地 O(n) 建树状数组
    for (int x = 1; x &lt;= n; ++x)
        for (int i = x - 1; i &gt;= x - lowbit(x) + 1; i -= lowbit(i))
            tr[x] += tr[i], tri[x] += tri[i];
    //读入查询
    while (m--)
    {
        char op[2];
        int l, r, c;
        scanf(&quot;%s&quot;, op);
        if (op[0] == &#39;Q&#39;)
        {
            scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
            printf(&quot;%lld\n&quot;, get_sum(r) - get_sum(l - 1));
        }
        else
        {
            scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c);
            add(tr, l, c), add(tr, r + 1, -c);
            add(tri, l, l * c), add(tri, r + 1, (r + 1) * -c);
        }
    }
    return 0;
}
链接：https://www.acwing.com/solution/content/44886/
</code></pre>
	<p>&nbsp;</p>
	<h2 id='博弈论'>博弈论</h2>
	<p>我一直以为博弈论是一个十分玄学的东西（<del>现在也这么认为</del>），不过在比赛中遇到的博弈论一般都是从某个基本的模型变形过来的，而学习了sg值后又将博弈论的状态和图联系了起来，虽然在时间上复杂度会过高不能作为提交的答案，但是可以利用sg值进行打表找规律，遇到博弈论时不会那么无助。mex是从0开始的集合中未出现的最小自然数，而sg函数是所有子问题的sg值构成集合的mex值，如果求解的子问题和多个子问题有关，让ans=0和每个子问题的sg值进行异或即可。最后ans=0则必败，否则为必胜。
	</p>
	<p>求sg的代码（主要用于打表）</p>
	<pre><code class='language-c++' lang='c++'>int n, k;
ll sg[N + 1];
int num[N];
ll a;
int SG(ll x)
{
	if (sg[x] != -1) return sg[x];
	if (x &gt;= a) return 0;
	map&lt;int, bool&gt; vis;
	int val;
	rep(i, 2, 9)
	{
		val = SG(i * x);
		vis[val] = true;
	}
	rep(i, 0, INT_MAX)
	{
		if (vis.count(i) == 0)
		{
			sg[x] = i;
			break;
		}
	}
	return sg[x];
}
</code></pre>
	<p><img src="C:\Users\黎明终点x\AppData\Roaming\Typora\typora-user-images\image-20210811010350012.png"
			referrerpolicy="no-referrer" alt="image-20210811010350012"></p>
	<p>求解博弈论，就要找出所有的必胜态和必败态，能一步到达必败态的都为必胜态，所有后继状态都为必胜态的为必败态。</p>
	<p>下面列出几个基本的结论：</p>
	<h3 id='1）巴什博弈'>（1）巴什博弈</h3>
	<p>n个物品， 每次可以取[1, m] 中任意一个， 不能取的人输</p>
	<p>如果n % (m + 1) == 0 则先手必败， 反之先手必胜</p>
	<p>设 ret = n % （m + 1)</p>
	<p>如果 ret 不为0 则先手可以拿 ret 个， 使得剩下的个数为 m + 1 的倍数</p>
	<p>之后无论后手拿[1, m] 中的任意一个x， 先手都必定可以拿 m + 1 - x， 所以先手必胜， 反之， 如果 ret 为 0 , 那无论先手拿多少个后手都必定可以按照上述策略应对， 先手必败</p>
	<h3 id='2）对称博弈'>（2）对称博弈</h3>
	<p>有 n 个石子， 每次可以拿连续的[1, m] 中的任意一个， 不能拿的人就输了</p>
	<p>m为1时， n为奇数先手赢， 反之后手赢</p>
	<p>m大于1时 先手赢</p>
	<p>m为1时的结论显然是对的</p>
	<p>m不为1时</p>
	<p>先手可以通过一些手段将石子平分成两堆完全一致的石子(奇数拿中间一个, 偶数拿中间两个)</p>
	<p>同时对于如下问题</p>
	<p>在一个半径为 R 的圆内放半径为 r 的圆， 圆不能互相有重叠部分（但是可以相切), 不能放的人就输了</p>
	<p>当R&gt;r时先手必胜，可以把圆放在正中间，然后就是对称博弈的问题了。</p>
	<h3 id='3）斐波那契博弈'>（3）斐波那契博弈</h3>
	<p>有 n 个石子， 第一个人至少取1个， 最多随便取， 但是第一回合不能直接取完</p>
	<p>之后每个人取得数目至少为1， 至多为上一个人取的石子数目的二倍， 不能取的人输</p>
	<p>结论 : 当 n 为斐波那契数列中的某个数字时， 先手必败， 反之必胜</p>
	<h3 id='4）威佐夫博弈'>（4）威佐夫博弈</h3>
	<p>有两堆石子， 每个人可以从一堆取任意个石子或者从两堆取任意相同数目的石子， 不能取的人就输了</p>
	<p>结论 ： 设两堆为 a, b 且 a &gt;= b , S为黄金分割数 ( sqrt(5) + 1) / 2</p>
	<p> 则 b = floor(S * (a - b)) 时 先手必败， 反之必胜 </p>
	<h1 id='分块和莫队'>分块和莫队</h1>
	<p>区间分块用于解决多个区间的查询和修改的问题。考虑到解决问题时，区间一般比较难处理的是区间的两个端点，而区间中很大一部分其实很好维护。所以我们采用分块的思想，将区间的两个端点置于不同的两个块中，直接用暴力的方法求解两个区间端点到块的端点的答案，而对于中间的区间，我们可以用一个tag数组来表示他们的变化，在查询的时候将tag数组反映到答案中即可。块的长度取sqrt(n)的时候，复杂度最小。
	</p>
	<pre><code class='language-c++' lang='c++'>//下标和块号从0开始	
block = sqrt(k);
	bn = ceil(k / block);
	for (int i = 0; i &lt; k; i++)
	{
		be[i] = i / block;
	}
	for (int i = 0; i &lt; bn; i++)
	{
		l[i] = i * block;
		r[i] = l[i] + block - 1;
	}
	r[bn - 1] = min(r[bn - 1], k - 1);
</code></pre>
	<pre><code class='language-c++' lang='c++'>//下标块号从1开始
block = floor(sqrt(n));
	num = (n - 1) / block + 1;
	rep(i, 1, n)
	{
		l[i] = (i - 1) * block + 1;
		r[i] = i * block;
		belong[i] = (i - 1) / block + 1;
	}
</code></pre>
	<p>维护区间和：这个简单，直接加起来更新ans即可</p>
	<pre><code class='language-c++' lang='c++'>//按下标来分
#pragma warning(disable : 4996)
using namespace std;
#define rep(l,a,b) for(ll l=a;l&lt;=b;l++)
#define repp(l,a,b) for(ll l=a;l&gt;=b;l--)
#define mem(x) memset(x,0,sizeof(x))
#define fr fast_IO::read()
#define INF 0x3f3f3f3f
namespace fast_IO {
	ll read() {
		ll num = 0;
		char c;
		bool tag = false;
		while ((c = getchar()) != &#39;-&#39; &amp;&amp; c != &#39;+&#39; &amp;&amp; (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) &amp;&amp; ~c);
		if (!~c)return EOF;
		if (c == &#39;-&#39;)tag = true;
		else if (c == &#39;+&#39;)tag = false;
		else num = c ^ 48;
		while ((c = getchar()) &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)
			num = (num &lt;&lt; 1) + (num &lt;&lt; 3) + (c ^ 48);
		if (tag)return -num;
		return num;
	}
}
const ll mod = 50001;
#define N 1000000
int n, k, block, num;
int a[N], sum[N], l[N], r[N], tag[N], belong[N];
void newlen(int x, int y, int c)
{
	ll nl = belong[x], nr = belong[y];
	if (nl == nr)
		rep(i, x, y)
		a[i] += c;
	else
	{
		rep(i, x, r[nl])
			a[i] += c;
		rep(i, l[nr], y)
			a[i] += c;
		rep(i, nl + 1, nr - 1)
			tag[i] += c;
	}
}
ll query(int x)
{
	int nx = belong[x];
	return a[x] + tag[nx];
}
ll query2(int x, int y)
{
	ll ans = 0;
	ll nl = belong[x], nr = belong[y];
	rep(i, x, r[nl])
		ans += a[i];
	rep(i, l[nr], y)
		ans += a[i];
	rep(i, nl + 1, nr - 1)
		ans += tag[i] * block;
	return ans;
}
signed main()
{
	//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	n = fr;
	rep(i, 1, n)
		a[i] = fr;
	block = floor(sqrt(n));
	num = (n - 1) / block + 1;
	rep(i, 1, n)
	{
		l[i] = (i - 1) * block + 1;
		r[i] = i * block;
		belong[i] = (i - 1) / block + 1;
	}
	rep(i, 1, num)//预处理
		rep(j, l[i], r[i])
		sum[i] += a[j];
	mem(tag);
	rep(i, 1, n)
	{
		int opt, l, r, c;
		opt = fr, l = fr, r = fr, c = fr;
		if (opt == 0)
			newlen(l, r, c);
		else
			printf(&quot;%lld\n&quot;, query(r));
	}
}
</code></pre>
	<p>某个区间中小于某个数的个数：</p>
	<p>涉及到个数的时候，可以先用一个数组备份原来的数据，然后让另一个数组分块排序。两个端点采用暴力的做法更新答案个查询答案（两端点可别用二分啊，排序后的下标会有变化），中间的块用二分的方法。统计出来即可。</p>
	<pre><code class='language-c++' lang='c++'>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;ctime&gt;
#include &lt;limits.h&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;iomanip&gt;
#define ll long long
#define int long long
#define um unordered_map
#pragma warning(disable : 4996)
using namespace std;
#define rep(l,a,b) for(ll l=a;l&lt;=b;l++)
#define repp(l,a,b) for(ll l=a;l&gt;=b;l--)
#define mem(x) memset(x,0,sizeof(x))
#define fr fast_IO::read()
#define INF 0x3f3f3f3f
namespace fast_IO {
ll read() {
    ll num = 0;
    char c;
    bool tag = false;

    while ((c = getchar()) != &#39;-&#39; &amp;&amp; c != &#39;+&#39; &amp;&amp; (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) &amp;&amp; ~c);

    if (!~c)
        return EOF;

    if (c == &#39;-&#39;)
        tag = true;
    else if (c == &#39;+&#39;)
        tag = false;
    else
        num = c ^ 48;

    while ((c = getchar()) &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)
        num = (num &lt;&lt; 1) + (num &lt;&lt; 3) + (c ^ 48);

    if (tag)
        return -num;

    return num;
}
}
const ll mod = 50001;
#define N 1000000
int n, k, block, num;
int a[N], sum[N], l[N], r[N], tag[N], belong[N], b[N];
void newlen(int x, int y, int c) {
    ll nl = belong[x], nr = belong[y];

    if (nl == nr) {
        rep(i, x, y)
        a[i] += c;
        rep(i, l[nl], r[nl])
        b[i] = a[i];
        sort(b + l[nl], b + r[nl] + 1);
    } else {
        rep(i, x, r[nl])
        a[i] = a[i] + c;
        rep(i, l[nl], r[nl])
        b[i] = a[i];
        sort(b + l[nl], b + r[nl] + 1);
        rep(i, nl + 1, nr - 1) {
            tag[i] += c;
        }
        rep(i, l[nr], y)
        a[i] = a[i] + c;
        rep(i, l[nr], r[nr])
        b[i] = a[i];
        sort(b + l[nr], b + r[nr] + 1);
    }
}
ll query2(int x, int y, int cc) {
    ll nl = belong[x], nr = belong[y];
    ll ans = 0;

    if (nl == nr) {
        rep(i, x, y)

        if (a[i] + tag[nl] &lt; cc)
            ans++;
    } else {
        rep(i, x, r[nl])

        if (a[i] + tag[nl] &lt; cc)
            ans++;

        rep(i, nl + 1, nr - 1) {
            ans += lower_bound(b + l[i], b + r[i] + 1, cc - tag[i]) - b - l[i];
        }
        rep(i, l[nr], y)

        if (a[i] + tag[nr] &lt; cc)
            ans++;
    }

    return ans;
}
signed main() {
    //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    n = fr;
    rep(i, 1, n)
    a[i] = fr, b[i] = a[i];
    block = floor(sqrt(n));
    num = (n - 1) / block + 1;
    rep(i, 1, n) {
        l[i] = (i - 1) * block + 1;
        r[i] = i * block;
        belong[i] = (i - 1) / block + 1;
    }
    rep(i, 1, num)
    sort(b + l[i], b + r[i] + 1);

    mem(tag);
    rep(i, 1, n) {
        int opt, l, r, c;
        opt = fr, l = fr, r = fr, c = fr;

        if (opt == 0)
            newlen(l, r, c);
        else
            printf(&quot;%lld\n&quot;, query2(l, r, c * c));
    }
}
</code></pre>
	<p>主函数部分大致都一样，区间分块的题只需要修改添加和查询函数，进行不同的预处理方法即可。预处理要方便求出后续的答案，比如求和需要求区间的和，查找数量需要提前排序。</p>
	<p>莫队是一种离线算法，不能用于强制在线的题目。莫队用于解决多区间的查询修改问题。莫队的思想是用暴力的方法求出第一个区间答案，然后将这个区间转移到其他区间，解决出其他区间的答案，转移到其他区间通过添加元素和删除元素完成，这个过程复杂度需要是O(1)，否则复杂度会爆炸，为了让转移的过程更加方便，我们将所需要读入的区间存入结构体，按照某种规则进行排序（分块法），让区间相似的区间集中在一起改变，从而能降低复杂度。复杂度为O(nsqrt(n))。莫队的代码模式都相同，只是不同的题需要找到不同的add函数和del函数，找到这个后问题就迎刃而解。（但是想找到合适的转移的函数真的好难QWQ，数学蠢才的叹息）。
	</p>
	<p>莫队的板子</p>
	<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;unordered_map&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#include&lt;ctime&gt;
#include&lt;limits.h&gt;
#include &lt;stack&gt;
#include&lt;set&gt;
#include&lt;iomanip&gt;
#define ll long long
#define int long long
#define um unordered_map
#pragma warning(disable : 4996)
using namespace std;
#define rep(l,a,b) for(ll l=a;l&lt;=b;l++)
#define repp(l,a,b) for(ll l=a;l&gt;=b;l--)
#define mem(x) memset(x,0,sizeof(x))
#define fr fast_IO::read()
#define INF 0x3f3f3f3f
namespace fast_IO {
	ll read() {
		ll num = 0;
		char c;
		bool tag = false;
		while ((c = getchar()) != &#39;-&#39; &amp;&amp; c != &#39;+&#39; &amp;&amp; (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) &amp;&amp; ~c);
		if (!~c)return EOF;
		if (c == &#39;-&#39;)tag = true;
		else if (c == &#39;+&#39;)tag = false;
		else num = c ^ 48;
		while ((c = getchar()) &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)
			num = (num &lt;&lt; 1) + (num &lt;&lt; 3) + (c ^ 48);
		if (tag)return -num;
		return num;
	}
}
const ll mod = 50001;
#define N 1000000
int n, m, k, block, belong[N], a[N], ans[N], cnt[N];
struct Q
{
	int l, r, id;
	bool operator&lt;(const Q&amp; b)
	{
		if (belong[l] != belong[b.l]) return l &lt; b.l;
		else return r &lt; b.r;
	}
}query[N];
int L, R, ret;
void add(int x)
{
	if (cnt[x] == 0)
	{
		cnt[x] = 1;
	}
	else
	{
		ret++;
		cnt[x]++;
	}
}
void del(int x)
{
	if (cnt[x] &gt; 1)
	{
		cnt[x]--;
		ret--;
	}
	else
	{
		cnt[x] = 0;
	}
}
signed main()
{
	//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	n = fr, m = fr;
	L = 1, R = 0;
	rep(i, 1, n)
		a[i] = fr;
	rep(i, 1, m)
	{
		int l = fr, r = fr;
		query[i] = { l,r,i };
	}
	block = sqrt(n);
	rep(i, 1, n) belong[i] = (i - 1) / block + 1;
	sort(query + 1, query + m + 1);
	rep(i, 1, m)
	{
		int l = query[i].l, r = query[i].r, id = query[i].id;
		while (R &lt; r) add(a[++R]);
		while (L &gt; l)  add(a[--L]);
		while (R &gt; r) del(a[R--]);
		while (L &lt; l) del(a[L++]);
		ans[id] = ret;
	}
	rep(i, 1, m)
	{
		if (ans[i] &gt; 0) cout &lt;&lt; &quot;No&quot; &lt;&lt; &quot;\n&quot;;
		else cout &lt;&lt; &quot;Yes&quot; &lt;&lt; &quot;\n&quot;;
	}
}
</code></pre>
	<p>遇到前缀和相关的问题时可能需要统计[l-1,r]的值。异或的逆运算就是他本身，a^b=k,则有b=a^k。</p>
</body>

</html>